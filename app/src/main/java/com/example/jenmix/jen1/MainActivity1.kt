package com.example.jenmix.jen1

import android.app.DatePickerDialog
import android.app.Dialog
import android.graphics.Color
import android.os.Bundle
import android.util.Log
import android.view.MotionEvent
import android.view.View
import android.widget.ArrayAdapter
import android.widget.AutoCompleteTextView
import android.widget.Button
import android.widget.ImageButton
import android.widget.ProgressBar
import android.widget.Switch
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.github.mikephil.charting.charts.LineChart
import com.github.mikephil.charting.components.Legend.LegendHorizontalAlignment
import com.github.mikephil.charting.components.Legend.LegendOrientation
import com.github.mikephil.charting.components.Legend.LegendVerticalAlignment
import com.github.mikephil.charting.components.LimitLine
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.IndexAxisValueFormatter
import com.github.mikephil.charting.formatter.ValueFormatter
import com.github.mikephil.charting.highlight.Highlight
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet
import com.github.mikephil.charting.listener.ChartTouchListener
import com.github.mikephil.charting.listener.OnChartGestureListener
import com.github.mikephil.charting.listener.OnChartValueSelectedListener
import com.google.android.material.button.MaterialButton
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale
import android.view.ViewTreeObserver
import com.example.jenmix.R
import kotlin.text.contains

class MainActivity1 : AppCompatActivity() {
    // View ÂÖÉ‰ª∂
    private lateinit var api: ApiService
    private lateinit var userSpinner: AutoCompleteTextView
    private lateinit var dateSpinner: AutoCompleteTextView
    private lateinit var rangeSpinner: AutoCompleteTextView
    private lateinit var btnAnalyze: MaterialButton
    private lateinit var resultView: TextView
    private lateinit var loadingIndicator: ProgressBar
    private lateinit var switchToggleView: Switch
    private lateinit var switchShowDetails: Switch
    private lateinit var chart: LineChart
    private var latestXLabels: List<String> = emptyList()
    private lateinit var diseaseSpinner: AutoCompleteTextView
    private var selectedDiseaseFilter: String? = null
    private var customStartDate: String? = null
    private var customEndDate: String? = null
    private var formattedDateLabels: List<String> = emptyList()
    private var lastSelectionType: SelectionType = SelectionType.NONE

    // Ë≥áÊñôÊ∏ÖÂñÆ
    private var users: List<String> = emptyList()
    private val ranges = listOf("‰∏ÄÈÄ±", "‰∏ÄÂÄãÊúà", "ÂçäÂπ¥", "‰∏ÄÂπ¥", "Á∏ΩÂàÜÊûê")
    private var selectedRange: String? = null

    enum class SelectionType {
        DATE_RANGE, ANALYSIS_RANGE, NONE
    }

    // ÁñæÁóÖËàá‰∏ªË¶ÅÊåáÊ®ôÂ∞çÊáâÔºàÁî®ÊñºÂúñË°®Ê®ôË®òÔºâ
    private val diseaseSeriesMapping = mapOf(
        "È´òË°ÄÂ£ì" to listOf("systolic", "diastolic"),
        "Ë°ÄÂ£ìÂÅèÈ´ò" to listOf("systolic", "diastolic"),
        "‰ΩéË°ÄÂ£ì" to listOf("systolic", "diastolic"),
        "ËÑàÊêèÂ§™È´ò" to listOf("pulse"),
        "È´òËÑàÊêè" to listOf("pulse"),
        "ËÑàÊêèÂ§™‰Ωé" to listOf("pulse"),
        "‰ΩéËÑàÊêè" to listOf("pulse"),
    )

    // ÁñæÁóÖÊ®ôË®òÔºöÈ°èËâ≤ËàáË™™Êòé
    private val diseaseMapping = mapOf(
        "È´òË°ÄÂ£ì" to Pair(Color.RED, "Êî∂Á∏ÆÂ£ì‚â•140ÊàñËàíÂºµÂ£ì‚â•90"),
        "Ë°ÄÂ£ìÂÅèÈ´ò" to Pair(Color.parseColor("#FFA500"), "Êî∂Á∏ÆÂ£ì120‚Äì130ÊàñËàíÂºµÂ£ì80"),
        "‰ΩéË°ÄÂ£ì" to Pair(Color.BLUE, "Êî∂Á∏ÆÂ£ì‚â§90ÊàñËàíÂºµÂ£ì‚â§60"),
        "ËÑàÊêèÂ§™È´ò" to Pair(Color.MAGENTA, "ËÑàÊêè>120"),
        "È´òËÑàÊêè" to Pair(Color.YELLOW, "ËÑàÊêè‰ªãÊñº101-120"),
        "ËÑàÊêèÂ§™‰Ωé" to Pair(Color.CYAN, "ËÑàÊêè<50"),
        "‰ΩéËÑàÊêè" to Pair(Color.parseColor("#ADD8E6"), "ËÑàÊêè‰ªãÊñº50-59"),
    )

    // Áï∂Ââç‰ΩøÁî®ËÄÖÊÄßÂà•ËàáË∫´È´òÔºàÁî®Êñº MarkerViewÔºâ
    private var currentGender: String = "male"
    private var currentHeightM: Float = 1.70f

    // -------------------------------
    // ÂÅ•Â∫∑Ë©ï‰º∞Â∏∏Êï∏
    // -------------------------------
    private companion object {
        // ‚úÖ Êî∂Á∏ÆÂ£ìÔºàSystolicÔºâ
        const val LOW_SYSTOLIC_BP = 90            // ‰ΩéË°ÄÂ£ìÔºö‚â§ 90
        const val NORMAL_SYSTOLIC_MIN = 90
        const val NORMAL_SYSTOLIC_MAX = 120
        const val BORDERLINE_SYSTOLIC_MIN = 120   // ÂÅèÈ´òÔºö120‚Äì130
        const val BORDERLINE_SYSTOLIC_MAX = 130
        const val PREHIGH_SYSTOLIC_MIN = 130      // È´òË°ÄÂ£ìÂâçÊúüÔºö130‚Äì140
        const val PREHIGH_SYSTOLIC_MAX = 140
        const val HIGH_SYSTOLIC_BP = 140          // È´òË°ÄÂ£ìÔºö‚â• 140

        // ‚úÖ ËàíÂºµÂ£ìÔºàDiastolicÔºâ
        const val LOW_DIASTOLIC_BP = 60           // ‰ΩéË°ÄÂ£ìÔºö‚â§ 60
        const val NORMAL_DIASTOLIC_MIN = 60
        const val NORMAL_DIASTOLIC_MAX = 80
        const val BORDERLINE_DIASTOLIC = 80       // ÂÅèÈ´ò / ÂâçÊúüÔºö= 80
        const val PREHIGH_DIASTOLIC = 90          // È´òË°ÄÂ£ìÂâçÊúü‰∏äÈôê / È´òË°ÄÂ£ì‰∏ãÈôê
        const val HIGH_DIASTOLIC_BP = 90          // È´òË°ÄÂ£ìÔºö‚â• 90

        const val HIGH_PULSE_RATE = 120
        const val HIGH_PULSE_LOWER_BOUND = 101
        const val LOW_PULSE_RATE = 50
        const val LOW_PULSE_UPPER_BOUND = 59
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_health_analysis)

        bindViews()
        setupRetrofit()
        setupSpinners()
        setupButtons()

        loadUsersFromServer()

        findViewById<Switch>(R.id.switch_expand_chart).setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                Toast.makeText(this, "üîç ÊîæÂ§ß‰∏≠...", Toast.LENGTH_SHORT).show()
                showChartInDialog()
            }
        }
    }

    private fun bindViews() {
        userSpinner = findViewById(R.id.user_spinner)
        dateSpinner = findViewById(R.id.date_spinner)
        rangeSpinner = findViewById(R.id.range_spinner)
        diseaseSpinner = findViewById(R.id.disease_spinner)
        btnAnalyze = findViewById(R.id.analyze_btn)
        resultView = findViewById(R.id.result_view)
        loadingIndicator = findViewById(R.id.loading_indicator)
        switchToggleView = findViewById(R.id.switch_toggle_view)
        switchShowDetails = findViewById(R.id.switch_show_details)
        chart = findViewById(R.id.chart)
    }

    private fun setupRetrofit() {
        api = Retrofit.Builder()
            .baseUrl("http://192.168.0.10:3000/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }

    private fun loadUsersFromServer() {
        RetrofitClient.instance.getUsers().enqueue(object : Callback<List<String>> {
            override fun onResponse(call: Call<List<String>>, response: Response<List<String>>) {
                if (response.isSuccessful) {
                    users = response.body() ?: listOf()
                    val adapter = ArrayAdapter(
                        this@MainActivity1,
                        android.R.layout.simple_list_item_1,
                        users
                    )
                    userSpinner.setAdapter(adapter) // ‚úÖ Ë®≠ÂÆöÂà∞ AutoCompleteTextViewÔºàuserSpinnerÔºâ

                    userSpinner.setOnClickListener { userSpinner.showDropDown() }
                    userSpinner.setOnItemClickListener { _, _, _, _ ->
                        // Ê∏ÖÁ©∫ÂÖ∂‰ªñÈÅ∏È†Ö
                        dateSpinner.text = null
                        rangeSpinner.text = null
                        diseaseSpinner.text = null
                        selectedRange = null
                        selectedDiseaseFilter = null
                        resultView.text = ""
                        val selectedUser = userSpinner.text.toString().trim()
                        loadDatesForUser(selectedUser)
                    }

                } else {
                    Toast.makeText(this@MainActivity1, "ËºâÂÖ•‰ΩøÁî®ËÄÖÂ§±Êïó", Toast.LENGTH_SHORT).show()
                }
            }

            override fun onFailure(call: Call<List<String>>, t: Throwable) {
                Toast.makeText(this@MainActivity1, "ÈåØË™§: ${t.message}", Toast.LENGTH_SHORT).show()
            }
        })
    }

    private fun setupSpinners() {
        setupUserSpinner()
        setupDiseaseSpinner()
        setupDateSpinner()
        setupRangeSpinner()
    }

    private fun setupUserSpinner() {
        userSpinner.apply {
            setAdapter(ArrayAdapter(this@MainActivity1, android.R.layout.simple_list_item_1, users))
            setOnClickListener { showDropDown() }
            setOnItemClickListener { _, _, _, _ ->
                clearSelection()
                val selectedUser = text.toString().trim()
                loadDatesForUser(selectedUser)
                dateSpinner.visibility = View.VISIBLE
                rangeSpinner.visibility = View.VISIBLE
                diseaseSpinner.visibility = View.VISIBLE
            }
        }
    }

    private fun setupDiseaseSpinner() {
        val diseaseOptions = listOf("‰∏çÁØ©ÈÅ∏", "È´òË°ÄÂ£ì", "‰ΩéË°ÄÂ£ì", "ËÑàÊêèÁï∞Â∏∏")
        diseaseSpinner.apply {
            setAdapter(
                ArrayAdapter(
                    this@MainActivity1,
                    android.R.layout.simple_list_item_1,
                    diseaseOptions
                )
            )
            setOnClickListener { showDropDown() }
            setOnItemClickListener { _, _, position, _ ->
                clearSelection(except = "disease")
                selectedDiseaseFilter = when (diseaseOptions[position]) {
                    "‰∏çÁØ©ÈÅ∏" -> null
                    "È´òË°ÄÂ£ì", "‰ΩéË°ÄÂ£ì" -> "Ë°ÄÂ£ì"
                    "ËÑàÊêèÁï∞Â∏∏" -> "ËÑàÊêè"
                    else -> null
                }
                getSelectedUserOrWarn()?.let { drawChartForRecords(it, selectedRangeToDays()) }
            }
        }
    }

    private fun setupDateSpinner() {
        dateSpinner.setOnClickListener { showDateRangeDialog() }
        dateSpinner.setOnItemClickListener { _, _, _, _ -> clearSelection(except = "date") }
    }

    private fun setupRangeSpinner() {
        rangeSpinner.apply {
            setAdapter(
                ArrayAdapter(
                    this@MainActivity1,
                    android.R.layout.simple_list_item_1,
                    ranges
                )
            )
            setOnClickListener { showDropDown() }
            setOnItemClickListener { _, _, position, _ ->
                clearSelection(except = "range")
                selectedRange = ranges[position]
                lastSelectionType = SelectionType.ANALYSIS_RANGE
            }
        }
    }

    private fun setupButtons() {
        btnAnalyze.setOnClickListener { performAnalysis() }

        switchShowDetails.setOnCheckedChangeListener { _, isChecked ->
            if (chart.visibility == View.VISIBLE) {
                getSelectedUserOrWarn()?.let {
                    drawChartForRecords(it, selectedRangeToDays())
                }
            }
        }

        switchToggleView.setOnCheckedChangeListener { _, isChecked ->
            resultView.visibility = if (isChecked) View.GONE else View.VISIBLE
            chart.visibility = if (isChecked) View.VISIBLE else View.GONE

            if (isChecked) {
                getSelectedUserOrWarn()?.let {
                    if (!customStartDate.isNullOrBlank() && !customEndDate.isNullOrBlank()) {
                        drawChartForRecords(it)
                    } else {
                        drawChartForRecords(it, selectedRangeToDays())
                    }
                }
            }
        }
    }

    private fun selectedRangeToDays(): Int? = when (selectedRange) {
        "‰∏ÄÈÄ±" -> 7
        "‰∏ÄÂÄãÊúà" -> 30
        "ÂçäÂπ¥" -> 180
        "‰∏ÄÂπ¥" -> 365
        else -> null
    }

    private fun clearSelection(except: String = "") {
        if (except != "date") dateSpinner.text = null
        if (except != "range") rangeSpinner.text = null
        if (except != "disease") diseaseSpinner.text = null
        if (except != "range") selectedRange = null
        if (except != "disease") selectedDiseaseFilter = null
        resultView.text = ""
    }

    // üîΩ performAnalysis ÊñπÊ≥ïÔºöÈÇèËºØÁµ±Êï¥Âåñ
    private fun performAnalysis() {
        val user = getSelectedUserOrWarn() ?: return

        when {
            // ‚úÖ Ëá™Ë®ÇÂçÄÈñì
            !customStartDate.isNullOrBlank() && !customEndDate.isNullOrBlank() -> {
                if (customStartDate == customEndDate) {
                    setLoading(true, "üîÑ ÂàÜÊûê ${customStartDate} Áï∂Êó•Ë≥áÊñô...")
                    api.getSingleAnalysis(user, customStartDate!!)
                        .enqueue(createAnalysisCallback(user))
                } else {
                    setLoading(true, "üîÑ ÂàÜÊûê ${customStartDate} Âà∞ ${customEndDate} ÁöÑË≥áÊñô...")
                    api.getCustomRangeAnalysis(user, customStartDate!!, customEndDate!!)
                        .enqueue(createAnalysisCallback(user))
                }
            }
            // ‚úÖ ÈÅ∏ÂñÆÊó•ÔºàÁÑ°Ëá™Ë®ÇÔºâ
            dateSpinner.text.toString().trim().matches(Regex("""\\d{4}-\\d{2}-\\d{2}""")) -> {
                val date = dateSpinner.text.toString().trim()
                selectedRange = null
                rangeSpinner.text = null
                setLoading(true, "üîÑ ÂàÜÊûêÂñÆÊó•Ë≥áÊñô...")
                api.getSingleAnalysis(user, date).enqueue(createAnalysisCallback(user))
            }
            // ‚úÖ ÈÅ∏ÊìáÂõ∫ÂÆöÁØÑÂúç
            !selectedRange.isNullOrBlank() -> {
                when (selectedRange) {
                    "Á∏ΩÂàÜÊûê" -> {
                        setLoading(true, "üîÑ Ê≠£Âú®ÂàÜÊûêÊâÄÊúâË≥áÊñô...")
                        api.getAllAggregate(user).enqueue(createAnalysisCallback(user))
                    }

                    else -> analyzeRange(user, selectedRangeToDays() ?: 0)
                }
            }

            else -> {
                showToast("Ë´ãÂÖàÈÅ∏ÊìáÊó•ÊúüÊàñÁØÑÂúç")
            }
        }
    }


    // üîΩ createAnalysisCallback ÊèêÂèñÈáçË§áËôïÁêÜÈÇèËºØ„ÄÅ‰øùÊåÅÁµêÊßãÊ∏ÖÊô∞
    private fun createAnalysisCallback(user: String): Callback<AnalysisResult> =
        object : Callback<AnalysisResult> {
            override fun onResponse(
                call: Call<AnalysisResult>,
                response: Response<AnalysisResult>
            ) {
                setLoading(false)
                if (response.isSuccessful) {
                    response.body()?.let { showResult(it) }
                        ?: run {
                            resultView.text = "‚ùå Êü•ÁÑ°ÂàÜÊûêË≥áÊñô"
                            Log.d("HealthAnalysis", "ÂõûÂÇ≥Á©∫Ë≥áÊñô")
                        }
                } else {
                    resultView.text = "‚ùå ÂàÜÊûêÂ§±Êïó"
                    Log.d("HealthAnalysis", "ÂàÜÊûêÂ§±ÊïóÔºåÁãÄÊÖãÁ¢ºÔºö${response.code()}")
                }
            }

            override fun onFailure(call: Call<AnalysisResult>, t: Throwable) {
                setLoading(false)
                resultView.text = "‚ùå ÈåØË™§Ôºö${t.message}"
                Log.d("HealthAnalysis", "API ÂëºÂè´Â§±ÊïóÔºö${t.message}")
            }
        }


    // üîΩ showDateRangeDialog ‰øùÊåÅÂäüËÉΩ‰∏çËÆäÔºå‰ΩÜÂä†‰∏äË®ªËß£ËàáÈÇèËºØÊ∏ÖÊô∞
    private fun showDateRangeDialog() {
        val dialog = Dialog(this)
        dialog.setContentView(R.layout.dialog_date_range)

        val btnStart = dialog.findViewById<Button>(R.id.btnStartDate)
        val btnEnd = dialog.findViewById<Button>(R.id.btnEndDate)
        val btnConfirm = dialog.findViewById<Button>(R.id.btnConfirm)

        val calendar = Calendar.getInstance()
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())

        btnStart.setOnClickListener {
            DatePickerDialog(
                this,
                { _, y, m, d ->
                    val date = Calendar.getInstance().apply { set(y, m, d) }
                    customStartDate = sdf.format(date.time)
                    btnStart.text = "ÈñãÂßãÔºö$customStartDate"
                },
                calendar.get(Calendar.YEAR),
                calendar.get(Calendar.MONTH),
                calendar.get(Calendar.DAY_OF_MONTH)
            ).show()
        }

        btnEnd.setOnClickListener {
            DatePickerDialog(
                this,
                { _, y, m, d ->
                    val date = Calendar.getInstance().apply { set(y, m, d) }
                    customEndDate = sdf.format(date.time)
                    btnEnd.text = "ÁµêÊùüÔºö$customEndDate"
                },
                calendar.get(Calendar.YEAR),
                calendar.get(Calendar.MONTH),
                calendar.get(Calendar.DAY_OF_MONTH)
            ).show()
        }

        btnConfirm.setOnClickListener {
            if (customStartDate != null && customEndDate != null) {
                dateSpinner.setText("$customStartDate Âà∞ $customEndDate", false)
                clearSelection(except = "date")
                lastSelectionType = SelectionType.DATE_RANGE
            } else {
                showToast("Ë´ãÈÅ∏ÊìáÂÆåÊï¥ÂçÄÈñì")
            }
            dialog.dismiss()
        }

        dialog.show()
    }

    private fun showResult(res: AnalysisResult) {
        val icon = when (res.È¢®Èö™Á≠âÁ¥ö) {
            "È´òÁ¥ö" -> "üî¥"
            "‰∏≠Á¥ö" -> "üü°"
            "ÂàùÁ¥ö" -> "üü¢"
            else -> "‚ö™"
        }

        val dateToShow = when (lastSelectionType) {
            SelectionType.DATE_RANGE -> {
                if (!customStartDate.isNullOrBlank() && !customEndDate.isNullOrBlank()) {
                    if (customStartDate == customEndDate) customStartDate!!
                    else "$customStartDate Âà∞ $customEndDate"
                } else {
                    res.record_date
                }
            }

            SelectionType.ANALYSIS_RANGE -> selectedRange ?: res.record_date
            SelectionType.NONE -> res.record_date
        }

        val genderText = when (res.gender?.lowercase()) {
            "male", "Áî∑" -> "Áî∑ ‚ôÇÔ∏è"
            "female", "Â•≥" -> "Â•≥ ‚ôÄÔ∏è"
            else -> "Êú™Áü• ‚ö†Ô∏è"
        }

        val ageText = res.age?.let { "$it Ê≠≤" } ?: "Êú™Áü• ‚ö†Ô∏è"

        resultView.text = buildString {
            append("üë§ ‰ΩøÁî®ËÄÖÔºö${res.user}\n")
            append("üéÇ Âπ¥ÈΩ°„ÄÄÔºö$ageText\n")
            append("‚ößÔ∏è ÊÄßÂà•„ÄÄÔºö$genderText\n")
            append("üóìÔ∏è Êó•ÊúüÔºö$dateToShow\n")
            append("üìä È¢®Èö™Á≠âÁ¥öÔºö$icon ${res.È¢®Èö™Á≠âÁ¥ö}\n\n")
            append("‚úÖ ÂàÜÊûêÁµêÊûúÔºö\n")
            append(if (res.ÂàÜÊûêÁµêÊûú.isEmpty()) "ÔºéÁÑ°\n\n" else res.ÂàÜÊûêÁµêÊûú.joinToString("\n") { "Ôºé$it" } + "\n\n")
            append("‚ö†Ô∏è ‰∫§ÂèâÈ¢®Èö™Ôºö\n")
            append(if (res.‰∫§ÂèâÁãÄÊ≥Å.isEmpty()) "ÔºéÁÑ°\n\n" else res.‰∫§ÂèâÁãÄÊ≥Å.joinToString("\n") { "Ôºé$it" } + "\n\n")
            append("üìå ÂèØËÉΩÁóÖÁóáÔºö\n")
            append(if (res.ÂèØËÉΩÁóÖÁóá.isEmpty()) "ÔºéÁÑ°\n\n" else res.ÂèØËÉΩÁóÖÁóá.joinToString("\n") { "Ôºé$it" } + "\n\n")
            append("üí° Âª∫Ë≠∞Ôºö\n")
            append(if (res.Âª∫Ë≠∞.isEmpty()) "ÔºéÁÑ°" else res.Âª∫Ë≠∞.joinToString("\n") { "Ôºé$it" })
        }
    }

    // üîΩ openSuggestionUrl Áµ±‰∏ÄÈåØË™§ËôïÁêÜËàáÊèêÁ§∫È¢®Ê†º
    private fun openSuggestionUrl(disease: String) {
        Toast.makeText(this, "üìñ Ê≠£Âú®Êü•Ë©¢ $disease ÁöÑÂª∫Ë≠∞...", Toast.LENGTH_SHORT).show()
        api.getSourceUrl(disease).enqueue(object : Callback<UrlResponse> {
            override fun onResponse(call: Call<UrlResponse>, response: Response<UrlResponse>) {
                val url = response.body()?.url
                if (!url.isNullOrBlank()) {
                    Toast.makeText(this@MainActivity1, "‚úÖ Â∑≤Ë∑≥ËΩâËá≥Âª∫Ë≠∞Á∂≤Á´ô", Toast.LENGTH_SHORT)
                        .show()
                    WebViewActivity.start(this@MainActivity1, url)
                } else {
                    showToast("‚ùå Êü•ÁÑ°Âª∫Ë≠∞Á∂≤ÂùÄ")
                }
            }

            override fun onFailure(call: Call<UrlResponse>, t: Throwable) {
                showToast("‚ùå ÈÄ£Á∑öÂ§±ÊïóÔºö${t.message}")
            }
        })
    }

    // ‚úÖ Êõ¥Êñ∞ drawChartForRecords Âè™È°ØÁ§∫‰∏ªÁ∑ö + ÂèØÂàáÊèõ LimitLineÔºà‰∏çÂê´ÁñæÁóÖÈªûÔºâ
    private fun drawChartForRecords(user: String, days: Int? = null) {
        chart.clear()
        api.getRecords(user).enqueue(object : Callback<List<HealthRecord>> {
            override fun onResponse(
                call: Call<List<HealthRecord>>,
                response: Response<List<HealthRecord>>
            ) {
                val records = response.body().orEmpty()
                if (records.isEmpty()) {
                    showToast("ÁÑ°Ë®òÈåÑË≥áÊñô")
                    Log.d("HealthAnalysis", "Ë®òÈåÑË≥áÊñôÁÇ∫Á©∫")
                    return
                }

                val inputFormats = listOf(
                    SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()),
                    SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()),
                    SimpleDateFormat("yyyy/M/d", Locale.getDefault()),
                    SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", Locale.ENGLISH)
                )
                val outputFormat = SimpleDateFormat("M/d", Locale.getDefault())

                val parsedRecords = records.mapNotNull { record ->
                    val parsedDate = inputFormats.firstNotNullOfOrNull { fmt ->
                        runCatching { fmt.parse(record.measure_at) }.getOrNull()
                    }
                    parsedDate?.let { Pair(record, it) }
                }.sortedBy { it.second }

                val sortedRecords = parsedRecords.map { it.first }
                formattedDateLabels = parsedRecords.map { outputFormat.format(it.second) }

                val latestDate = parsedRecords.maxByOrNull { it.second }?.second
                val filteredRecords = when {
                    days != null && latestDate != null -> {
                        val cutoff = Calendar.getInstance().apply {
                            time = latestDate
                            add(Calendar.DAY_OF_YEAR, -days)
                        }.time
                        parsedRecords.filter { it.second.after(cutoff) }.map { it.first }
                    }

                    !customStartDate.isNullOrBlank() && !customEndDate.isNullOrBlank() -> {
                        val start = inputFormats[0].parse(customStartDate!!)!!
                        val end = inputFormats[0].parse(customEndDate!!)!!
                        parsedRecords.filter { it.second in start..end }.map { it.first }
                    }

                    else -> sortedRecords
                }

                if (filteredRecords.isEmpty()) {
                    showToast("Á¨¶ÂêàÊ¢ù‰ª∂ÁöÑË≥áÊñôÁÇ∫Á©∫")
                    chart.clear()
                    return
                }

                val systolicEntries = mutableListOf<Entry>()
                val diastolicEntries = mutableListOf<Entry>()
                val pulseEntries = mutableListOf<Entry>()
                var gender = "male"
                var height = 1.70f

                filteredRecords.forEachIndexed { index, rec ->
                    val x = index.toFloat()
                    val fixed = rec.copy(user = user)
                    systolicEntries.add(Entry(x, rec.systolic_mmHg.toFloat()).apply {
                        data = fixed
                    })
                    diastolicEntries.add(Entry(x, rec.diastolic_mmHg.toFloat()).apply {
                        data = fixed
                    })
                    pulseEntries.add(Entry(x, rec.pulse_bpm.toFloat()).apply { data = fixed })
                    gender = rec.gender
                    height = rec.height.toFloat() / 100f
                }

                val dataSets = mutableListOf<ILineDataSet>()
                if (selectedDiseaseFilter == null || selectedDiseaseFilter == "Ë°ÄÂ£ì") {
                    dataSets.add(createDataSet(systolicEntries, "Êî∂Á∏ÆÂ£ì", Color.RED, Color.RED))
                    dataSets.add(createDataSet(diastolicEntries, "ËàíÂºµÂ£ì", Color.BLUE, Color.BLUE))
                }
                if (selectedDiseaseFilter == null || selectedDiseaseFilter == "ËÑàÊêè") {
                    dataSets.add(createDataSet(pulseEntries, "ËÑàÊêè", Color.MAGENTA, Color.MAGENTA))
                }

                chart.data = LineData(dataSets)

                val entryCount = chart.data.entryCount
                val showCount = if (entryCount >= 10) 10f else entryCount.toFloat()
                chart.setVisibleXRangeMaximum(showCount)
                chart.moveViewToX(entryCount - showCount)

                // ‚úÖ ÂãïÊÖãÁî¢ÁîüÂñÆ‰Ωç
                val unitSet = mutableSetOf<String>()
                chart.data.dataSets.forEach { dataSet ->
                    when {
                        dataSet.label.contains("Êî∂Á∏ÆÂ£ì") || dataSet.label.contains("ËàíÂºµÂ£ì") -> unitSet.add("mmHg")
                        dataSet.label.contains("ËÑàÊêè") -> unitSet.add("bpm")
                    }
                }
                chart.post {
                    chart.description.isEnabled = true
                    chart.description.text = "ÂñÆ‰ΩçÔºö${unitSet.joinToString(" / ")}"
                    chart.description.textSize = 14f
                    chart.description.textColor = Color.DKGRAY
                    chart.description.setPosition(400f, 60f) // ‚úÖ ÈÄ≤‰æÜ‰∏ÄÈªûÈÅøÂÖçË¢´Êì†Âá∫
                    chart.invalidate() // ËÆìÂúñË°®Á´ãÂç≥Âà∑Êñ∞Áï´Èù¢
                }

                chart.xAxis.apply {
                    valueFormatter = IndexAxisValueFormatter(formattedDateLabels)
                    labelCount = formattedDateLabels.size
                    position = XAxis.XAxisPosition.BOTTOM
                    granularity = 1f
                    textSize = 14.5f
                    textColor = Color.DKGRAY
                }
                chart.axisLeft.textSize = 14.5f
                chart.axisRight.textSize = 14.5f
                chart.legend.apply {
                    textSize = 14.5f
                    formSize = 14.5f
                    xEntrySpace = 20f
                    yEntrySpace = 20f
                    isWordWrapEnabled = true
                    maxSizePercent = 0.7f
                }
                chart.axisLeft.axisMaximum = chart.yMax + 10f  // ‚úÖ Áµ¶‰∏äÊñπÂ§ö‰∏ÄÈªûÁ©∫Èñì
                chart.setExtraOffsets(0f, 30f, 0f, 20f)         // ‚úÖ ÈÅøÂÖçÂÖßÂÆπÂ§™Êì†
                chart.xAxis.setLabelCount(5, true)              // ‚úÖ ÈÅøÂÖçÊó•ÊúüÂ§™Â§öÂ£ìÂú®‰∏ÄËµ∑

                configureChart(chart)
                chart.marker = MyMarkerView(
                    this@MainActivity1,
                    R.layout.custom_marker_view,
                    chart,
                    gender,
                    height
                )

                val abnormalIndicators =
                    setOf("systolic", "diastolic", "pulse").filterByDisease().toSet()
                if (switchShowDetails.isChecked) {
                    addLimitLinesToChart(chart, abnormalIndicators)
                } else {
                    chart.axisLeft.removeAllLimitLines()
                }

                chart.invalidate()
            }

            override fun onFailure(call: Call<List<HealthRecord>>, t: Throwable) {
                showToast("ÂúñË°®Ë≥áÊñôËºâÂÖ•Â§±ÊïóÔºö${t.message}")
                Log.d("HealthAnalysis", "getRecords Â§±ÊïóÔºö${t.message}")
            }
        })
    }

    private fun addLimitLinesToChart(targetChart: LineChart, abnormalIndicators: Set<String>) {
        targetChart.axisLeft.removeAllLimitLines()

        fun createLimitLine(value: Float, label: String, color: Int): LimitLine {
            return LimitLine(value, label).apply {
                lineColor = color
                lineWidth = 1.5f
                textColor = color
                textSize = 15f
                enableDashedLine(8f, 6f, 0f)
                labelPosition = LimitLine.LimitLabelPosition.RIGHT_TOP // ‚úÖ È°ØÁ§∫Âú®Âè≥‰∏ä
                // ‚úÖ ÈÄô‰∏ÄË°åÂä†Â§ß Y ÂÅèÁßªÔºåËÆìÊ®ôÁ±§ÂæÄ‰∏ãÁßªÂãï‰∏ÄÈªû
                yOffset = 30f  // ‚Üê ÂéüÊú¨‰Ω†ÊáâË©≤Âè™Êúâ 12fÔºåÂª∫Ë≠∞ÊãâÂà∞ 30f ~ 40f ‰πãÈñì
                xOffset = 5f
            }
        }

        // ‚úÖ Ë°ÄÂ£ì
        if ("systolic" in abnormalIndicators || "diastolic" in abnormalIndicators) {
            // È´òË°ÄÂ£ì
            if ("È´òË°ÄÂ£ì" in diseaseMapping) {
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        140f,
                        "È´òË°ÄÂ£ìÔºàÂç±Èö™ÔºâÔºöÊî∂Á∏ÆÂ£ì‚â•140",
                        Color.RED
                    )
                )
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        90f,
                        "È´òË°ÄÂ£ìÔºàÂç±Èö™ÔºâÔºöËàíÂºµÂ£ì‚â•90",
                        Color.RED
                    )
                )
            }
            if ("È´òË°ÄÂ£ì" in diseaseMapping) {
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        130f,
                        "È´òË°ÄÂ£ìÔºàÂâçÊúüÔºâÔºöÊî∂Á∏ÆÂ£ì130‚Äì140",
                        Color.parseColor("#B22222")
                    ) // Ê∑±Á¥Ö
                )
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(80f, "È´òË°ÄÂ£ìÔºàÂâçÊúüÔºâÔºöËàíÂºµÂ£ì80‚Äì90", Color.parseColor("#B22222"))
                )
            }
            // Ë°ÄÂ£ìÂÅèÈ´ò
            if ("Ë°ÄÂ£ìÂÅèÈ´ò" in diseaseMapping) {
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        120f,
                        "Ë°ÄÂ£ìÂÅèÈ´òÔºöÊî∂Á∏ÆÂ£ì120‚Äì130",
                        Color.parseColor("#FFA500")
                    )
                )
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        80f,
                        "Ë°ÄÂ£ìÂÅèÈ´òÔºöËàíÂºµÂ£ì=80",
                        Color.parseColor("#FFA500")
                    )
                )
            }
            // ‰ΩéË°ÄÂ£ì
            if ("‰ΩéË°ÄÂ£ì" in diseaseMapping) {
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        90f,
                        "‰ΩéË°ÄÂ£ìÔºöÊî∂Á∏ÆÂ£ì‚â§90",
                        Color.BLUE
                    )
                )
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        60f,
                        "‰ΩéË°ÄÂ£ìÔºöËàíÂºµÂ£ì‚â§60",
                        Color.BLUE
                    )
                )
            }
        }

        // ‚úÖ ËÑàÊêè
        if ("pulse" in abnormalIndicators) {
            if ("ËÑàÊêèÂ§™È´ò" in diseaseMapping)
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        120.2f,
                        "ËÑàÊêèÂ§™È´òÔºö>120",
                        Color.MAGENTA
                    )
                )
            if ("È´òËÑàÊêè" in diseaseMapping)
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        101f,
                        "È´òËÑàÊêèÔºö101‚Äì120",
                        Color.parseColor("#FFA000")  // Ê∑±ÈªÉËâ≤
                    )
                )
            if ("ËÑàÊêèÂ§™‰Ωé" in diseaseMapping)
                targetChart.axisLeft.addLimitLine(createLimitLine(50f, "ËÑàÊêèÂ§™‰ΩéÔºö<50", Color.CYAN))
            if ("‰ΩéËÑàÊêè" in diseaseMapping)
                targetChart.axisLeft.addLimitLine(
                    createLimitLine(
                        59f,
                        "‰ΩéËÑàÊêèÔºö50‚Äì59",
                        Color.parseColor("#1565C0")  // Ê∑±ËóçËâ≤
                    )
                )
        }
    }

    // üîΩ configureChartÔºöÁµ±‰∏ÄÂúñË°®Ê®£ÂºèË®≠ÂÆö
    private fun configureChart(chart: LineChart) {
        chart.apply {
            description.isEnabled = false
            setTouchEnabled(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setDrawMarkers(true)
            setPinchZoom(true)
            setDoubleTapToZoomEnabled(false)
            setScaleYEnabled(false)

            // ‚úÖ Â¢ûÂä†‰∏ä‰∏ã paddingÔºåÈÅøÂÖçÊì†Â£ì
            setExtraOffsets(0f, 30f, 0f, 20f)

            axisLeft.apply {
                textSize = 14.5f
                textColor = Color.DKGRAY
                axisLineColor = Color.DKGRAY
                gridColor = Color.LTGRAY
                axisMaximum = axisMaximum + 10f  // ‚úÖ Â¢ûÂä† Y Ëª∏ÊúÄÂ§ßÂÄºÈÅøÂÖç‰∏äÈù¢Êì†Â£ì
            }
            axisRight.apply {
                isEnabled = true
                textSize = 14.5f
                textColor = Color.DKGRAY
                axisLineColor = Color.DKGRAY
                gridColor = Color.TRANSPARENT
            }
            legend.apply {
                verticalAlignment = LegendVerticalAlignment.TOP
                horizontalAlignment = LegendHorizontalAlignment.CENTER
                orientation = LegendOrientation.HORIZONTAL
                setDrawInside(false)
                isWordWrapEnabled = true
                maxSizePercent = 0.7f
                xEntrySpace = 16f
                yEntrySpace = 12f
                textSize = 12f
                formSize = 12f
            }
            // ‚úÖ ÈÅøÂÖç X Ëª∏Êó•ÊúüÊì†Â§™Â§ö
            xAxis.setLabelCount(5, true)
            setExtraOffsets(10f, 10f, 10f, 20f)
        }
    }

    // üîΩ createDataSetÔºöÁµ±‰∏ÄÁπ™ÂúñÂ±¨ÊÄßËàáÊ†ºÂºèÂåñ
    private fun createDataSet(
        entries: List<Entry>,
        label: String,
        lineColor: Int,
        circleColor: Int,
        lineWidth: Float = 3f,
        circleRadius: Float = 4f,
        valueTextSize: Float = 12f,
        drawValues: Boolean = true,
        unitLabel: String = ""
    ): LineDataSet {
        return LineDataSet(entries, label).apply {
            color = lineColor
            setCircleColor(circleColor)
            this.lineWidth = lineWidth
            this.circleRadius = circleRadius
            setValueTextSize(valueTextSize)
            setDrawValues(drawValues)
            mode = LineDataSet.Mode.LINEAR

            if (label in listOf("Êî∂Á∏ÆÂ£ì", "ËàíÂºµÂ£ì", "ËÑàÊêè")) {
                setDrawCircles(true)                  // ‚úÖ Áï´ÂúìÈªû
                setCircleRadius(6f)                  // ‚úÖ ÊîπÈÄôË£°ÔºÅËÆìÈªûËÆäÂ§ß
                setCircleColor(lineColor)            // ‚úÖ ‰∏ªÁ∑öÈ°èËâ≤
                setDrawValues(true)                  // ‚úÖ È°ØÁ§∫Êï∏ÂÄº
                setValueTextSize(14f)                 // ‚úÖ Â≠óÈ´îÂ§ßÂ∞è
                setValueTextColor(Color.BLACK)        // ‚úÖ Â≠óÈ´îÈ°èËâ≤
                mode = LineDataSet.Mode.LINEAR       // ‚úÖ Á∑öÊ¢ùÊ®°Âºè
                this.lineWidth = 3f
            }


            // ‚úÖ ÂñÆ‰ΩçÊ†ºÂºèÂåñÔºàÂèØ‰øùÁïôÔºâ
            if (unitLabel.isNotBlank()) {
                valueFormatter = object : ValueFormatter() {
                    override fun getPointLabel(entry: Entry?): String {
                        return entry?.y?.toInt()?.toString() ?: ""
                    }
                }
            }
        }
    }

    // ÂàÜÊûêË®òÈåÑ‰∏≠ÁöÑÁï∞Â∏∏ÊåáÊ®ô
    private fun analyzeRecord(record: HealthRecord): List<String> = listOfNotNull(
        getBloodPressureAnalysis(record),
        getPulseAnalysis(record),
    )

    private fun getBloodPressureAnalysis(record: HealthRecord): String? = when {
        record.systolic_mmHg >= HIGH_SYSTOLIC_BP || record.diastolic_mmHg >= HIGH_DIASTOLIC_BP -> "È´òË°ÄÂ£ì"
        record.systolic_mmHg in PREHIGH_SYSTOLIC_MIN until HIGH_SYSTOLIC_BP || record.diastolic_mmHg in BORDERLINE_DIASTOLIC until HIGH_DIASTOLIC_BP -> "È´òË°ÄÂ£ì"
        record.systolic_mmHg in BORDERLINE_SYSTOLIC_MIN until PREHIGH_SYSTOLIC_MIN || record.diastolic_mmHg == BORDERLINE_DIASTOLIC -> "Ë°ÄÂ£ìÂÅèÈ´ò"
        record.systolic_mmHg < LOW_SYSTOLIC_BP || record.diastolic_mmHg < LOW_DIASTOLIC_BP -> "‰ΩéË°ÄÂ£ì"
        else -> null
    }


    private fun getPulseAnalysis(record: HealthRecord): String? = when {
        record.pulse_bpm > HIGH_PULSE_RATE -> "ËÑàÊêèÂ§™È´ò"
        record.pulse_bpm in HIGH_PULSE_LOWER_BOUND..HIGH_PULSE_RATE -> "È´òËÑàÊêè"
        record.pulse_bpm < LOW_PULSE_RATE -> "ËÑàÊêèÂ§™‰Ωé"
        record.pulse_bpm in LOW_PULSE_RATE..LOW_PULSE_UPPER_BOUND -> "‰ΩéËÑàÊêè"
        else -> null
    }

    private fun loadDatesForUser(user: String) {
        api.getAvailableDates(user).enqueue(object : Callback<List<String>> {
            override fun onResponse(call: Call<List<String>>, response: Response<List<String>>) {
                response.body()?.let { dates ->
                    dateSpinner.setAdapter(
                        ArrayAdapter(
                            this@MainActivity1,
                            android.R.layout.simple_list_item_1,
                            dates
                        )
                    )
                    dateSpinner.text = null
                }
            }

            override fun onFailure(call: Call<List<String>>, t: Throwable) {
                showToast("‚ùå ËºâÂÖ•Êó•ÊúüÂ§±ÊïóÔºö${t.message}")
                Log.d("HealthAnalysis", "getAvailableDates Â§±ÊïóÔºö${t.message}")
            }
        })
    }

    private fun analyzeRange(user: String, days: Int) {
        val startDate = getDatabasePastDate(days) ?: run {
            analyzeAllData(user)
            return
        }
        setLoading(true, "üîÑ ÂàÜÊûêÊúÄËøë $days Â§©Ë≥áÊñô‰∏≠...")
        api.getRangeAnalysis(user, startDate).enqueue(createAnalysisCallback(user))
    }

    private fun analyzeAllData(user: String) {
        setLoading(true, "üîÑ Ê≠£Âú®ÂàÜÊûêÊâÄÊúâË≥áÊñô...")
        api.getAllAggregate(user).enqueue(createAnalysisCallback(user))
    }

    private fun getDatabasePastDate(days: Int): String? {
        val adapter = dateSpinner.adapter ?: return null
        return if (adapter.count > 0) {
            val latestDateStr = adapter.getItem(0).toString()
            runCatching {
                val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                val latestDate = sdf.parse(latestDateStr)
                Calendar.getInstance().apply {
                    time = latestDate ?: return null
                    add(Calendar.DAY_OF_YEAR, -days)
                }.let { sdf.format(it.time) }
            }.getOrNull()
        } else null
    }

    private fun getSelectedUserOrWarn(): String? {
        val user = userSpinner.text.toString().trim()
        return if (user.isEmpty()) {
            showToast("‚ö†Ô∏è Ë´ãÂÖàÈÅ∏Êìá‰ΩøÁî®ËÄÖ")
            null
        } else user
    }

    private fun showChartInDialog() {
        if (chart.data == null || chart.data.dataSetCount == 0) {
            showToast("ÁõÆÂâçÊ≤íÊúâÂèØÁî®ÁöÑÂúñË°®Ë≥áÊñô")
            return
        }

        Dialog(this, android.R.style.Theme_Black_NoTitleBar_Fullscreen).apply {
            setContentView(R.layout.dialog_chart_fullscreen)
            val fullChart = findViewById<LineChart>(R.id.dialog_chart)
            val closeBtn = findViewById<ImageButton>(R.id.btnCloseDialog)

            // ‚úÖ Ë§áË£Ω‰∏ªÂúñË≥áÊñô‰∏¶ÈÅéÊøæÔºöÂè™‰øùÁïô‰∏ªÁ∑ö (Êî∂Á∏ÆÂ£ì„ÄÅËàíÂºµÂ£ì„ÄÅËÑàÊêè)
            val filteredDataSets = chart.data.dataSets.filter {
                it.label in listOf("Êî∂Á∏ÆÂ£ì", "ËàíÂºµÂ£ì", "ËÑàÊêè")
            }
            fullChart.data = LineData(filteredDataSets)

            // ‚úÖ È°ØÁ§∫ÊúÄÂ§ö 10 Á≠Ü‰∏¶Ëá™ÂãïÊªæÂà∞ÊúÄÊñ∞
            val entryCount = fullChart.data.entryCount
            val showCount = if (entryCount >= 10) 10f else entryCount.toFloat()
            fullChart.setVisibleXRangeMaximum(showCount)
            fullChart.moveViewToX(entryCount - showCount)

            // ‚úÖ Ë£ú‰∏äÂñÆ‰ΩçÊèèËø∞
            val unitSet = mutableSetOf<String>()
            fullChart.data.dataSets.forEach { dataSet ->
                when {
                    dataSet.label.contains("Êî∂Á∏ÆÂ£ì") || dataSet.label.contains("ËàíÂºµÂ£ì") -> unitSet.add(
                        "mmHg"
                    )

                    dataSet.label.contains("ËÑàÊêè") -> unitSet.add("bpm")
                }
            }
            fullChart.post {
                fullChart.description.isEnabled = true
                fullChart.description.text = "ÂñÆ‰ΩçÔºö${unitSet.joinToString(" / ")}"
                fullChart.description.textSize = 16f
                fullChart.description.textColor = Color.DKGRAY
                fullChart.description.setPosition(
                    450f,
                    fullChart.viewPortHandler.contentTop() - 40f
                )
                fullChart.invalidate()
            }

            // ‚úÖ Â•óÁî®ÂñÆ‰ΩçÊ†ºÂºèÂåñÂô®
            fullChart.data.dataSets.forEach { dataSet ->
                val unit = when {
                    dataSet.label.contains("ËÑàÊêè") -> "bpm"
                    dataSet.label.contains("Êî∂Á∏ÆÂ£ì") || dataSet.label.contains("ËàíÂºµÂ£ì") -> "mmHg"
                    else -> ""
                }
                if (unit.isNotEmpty()) {
                    dataSet.valueFormatter = object : ValueFormatter() {
                        override fun getPointLabel(entry: Entry?): String {
                            return entry?.y?.toInt()?.toString() ?: ""
                        }
                    }
                }
            }

            // ‚úÖ Âä†ÂÖ• LimitLineÔºàÊ†πÊìö switchÔºâ
            val abnormalIndicators = mutableSetOf<String>().apply {
                if (filteredDataSets.any { it.label.contains("Êî∂Á∏ÆÂ£ì") }) add("systolic")
                if (filteredDataSets.any { it.label.contains("ËàíÂºµÂ£ì") }) add("diastolic")
                if (filteredDataSets.any { it.label.contains("ËÑàÊêè") }) add("pulse")
            }.filterByDisease().toSet()

            if (switchShowDetails.isChecked) {
                addLimitLinesToChart(fullChart, abnormalIndicators)
            } else {
                fullChart.axisLeft.removeAllLimitLines()
            }

            // ‚úÖ Ê®£ÂºèË®≠ÁΩÆËàá MarkerView
            configureChart(fullChart)
            fullChart.marker = MyMarkerView(
                this@MainActivity1,
                R.layout.custom_marker_view,
                fullChart,
                currentGender,
                currentHeightM
            )

            // ‚úÖ È°ØÁ§∫‰ΩøÁî®ËÄÖË≥áË®ä
            val infoText = findViewById<TextView>(R.id.user_info_text)
            val record =
                chart.data?.dataSets?.firstOrNull()?.getEntryForIndex(0)?.data as? HealthRecord
            val genderText = when (record?.gender?.lowercase()) {
                "male", "Áî∑" -> "Áî∑"
                "female", "Â•≥" -> "Â•≥"
                else -> "‚ö†Ô∏èÊú™Áü•"
            }
            val ageText = record?.age?.let { "$it Ê≠≤" } ?: "Êú™Áü•"
            infoText.text =
                "üë§ ${record?.user}ÔΩú‚ößÔ∏è ÊÄßÂà•Ôºö$genderTextÔΩúüéÇ Âπ¥ÈΩ°Ôºö$ageTextÔΩúüìè Ë∫´È´òÔºö${record?.height?.toInt()}cmÔΩú‚öñÔ∏è È´îÈáçÔºö${record?.weight}kgÔΩú"

            // ‚úÖ X Ëª∏Ë®≠ÂÆö
            fullChart.xAxis.apply {
                valueFormatter = IndexAxisValueFormatter(formattedDateLabels)
                setDrawLabels(true)
                position = XAxis.XAxisPosition.BOTTOM
                granularity = 1f
                labelRotationAngle = 0f
                textSize = 16.5f
                textColor = Color.DKGRAY
                setLabelCount(formattedDateLabels.size, true)
                gridColor = Color.LTGRAY
                gridLineWidth = 1.2f
                axisLineColor = Color.DKGRAY
                axisLineWidth = 1.5f
            }

            // ‚úÖ Y Ëª∏ËàáÂúñ‰æã
            fullChart.axisLeft.textSize = 16.5f
            fullChart.axisRight.textSize = 16.5f
            fullChart.legend.apply {
                textSize = 16.5f
                formSize = 16.5f
                xEntrySpace = 12f
                yEntrySpace = 12f
                verticalAlignment = LegendVerticalAlignment.TOP
                horizontalAlignment = LegendHorizontalAlignment.CENTER
                orientation = LegendOrientation.HORIZONTAL
                setDrawInside(false)
                yOffset = 30f
            }
            fullChart.setExtraOffsets(0f, 24f, 0f, 30f)

            // ‚úÖ ÈªûÈÅ∏Ë≥áÊñôÂæåÈñãÂïüÂª∫Ë≠∞Ôºà‰øùÁïô‰∫íÂãïÔºâ
            fullChart.setOnChartValueSelectedListener(object : OnChartValueSelectedListener {
                override fun onValueSelected(e: Entry?, h: Highlight?) {
                    if (e == null || h == null || fullChart.data == null) return
                    val record = e.data as? HealthRecord ?: return
                    val label = fullChart.data.getDataSetByIndex(h.dataSetIndex).label ?: return
                    val disease = when (label) {
                        "Êî∂Á∏ÆÂ£ì", "ËàíÂºµÂ£ì" -> getBloodPressureAnalysis(record)
                        "ËÑàÊêè" -> getPulseAnalysis(record)
                        else -> null
                    } ?: return

                    if (disease != "Ê≠£Â∏∏ÂÄº" && disease != "Êú™Áü•") {
                        Toast.makeText(
                            this@MainActivity1,
                            "üìñ Ê≠£Âú®ÈñãÂïüÔºö$disease Âª∫Ë≠∞...",
                            Toast.LENGTH_SHORT
                        ).show()
                        openSuggestionUrl(disease)
                    }
                }

                override fun onNothingSelected() {
                    fullChart.highlightValue(null)
                }
            })

            // ‚úÖ ÊâãÂã¢ÊéßÂà∂ÔºàÂèØÈÅ∏Ôºâ
            fullChart.setOnChartGestureListener(object : OnChartGestureListener {
                override fun onChartGestureStart(
                    me: MotionEvent?,
                    lastPerformedGesture: ChartTouchListener.ChartGesture?
                ) {
                }

                override fun onChartGestureEnd(
                    me: MotionEvent?,
                    lastPerformedGesture: ChartTouchListener.ChartGesture?
                ) {
                }

                override fun onChartLongPressed(me: MotionEvent?) {}
                override fun onChartDoubleTapped(me: MotionEvent?) {}
                override fun onChartSingleTapped(me: MotionEvent?) {}
                override fun onChartFling(
                    me1: MotionEvent?,
                    me2: MotionEvent?,
                    velocityX: Float,
                    velocityY: Float
                ) {
                }

                override fun onChartScale(me: MotionEvent?, scaleX: Float, scaleY: Float) {}
                override fun onChartTranslate(me: MotionEvent?, dX: Float, dY: Float) {}
            })

            closeBtn.setOnClickListener {
                (this@MainActivity1.findViewById<Switch>(R.id.switch_expand_chart)).isChecked = false
                dismiss()  // ‚úÖ ÊúÄÂæåÂÜçÈóúÊéâ Dialog
            }
            show()  // ‚úÖ ÊúÄÂæåÂëºÂè´ show()
        }
    }

    private fun setLoading(isLoading: Boolean, message: String = "") {
        btnAnalyze.isEnabled = !isLoading
        loadingIndicator.visibility = if (isLoading) View.VISIBLE else View.GONE
        if (message.isNotBlank()) resultView.text = message
    }

    private fun showToast(msg: String) {
        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
    }

    private fun Set<String>.filterByDisease(): Set<String> {
        return when (selectedDiseaseFilter) {
            "Ë°ÄÂ£ì" -> filter { it == "systolic" || it == "diastolic" }.toSet()
            "ËÑàÊêè" -> filter { it == "pulse" }.toSet()
            else -> this // ‰∏çÁØ©ÈÅ∏Ôºö‰øùÁïôÂÖ®ÈÉ®
        }
    }
}
